# 模块二：ES新特性与TypeScript、JS性能优化
## 简答题
## 1. 请说出下列最终的执行结果，并解释为什么
```js
var a= []
for(var i = 0; i < 10; i++){
  a[i] = function () {
    console.log(i)
  }
}
a[6]()
```
输出10
- var定义变量没有块的概念
- i是var声明的，在全局范围内有效，每一次循环，新的i值会覆盖旧的

## 二、请说出下列最终的执行结果，并解释为什么
```js
var tmp = 123;
if(true)
```
报错 ReferenceError
- let不能变量提升
- 只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。

## 四、请详细说明var，let，const三种声明变量的方式之间的具体差别
### var
- 只有全局作用域和函数作用域，没有块级作用域
  ### 带来不合理的场景
  - 内层变量可能会覆盖外层变量
  ```js
  var tmp = new Date();
  function f() {
    console.log(tmp);
    if (false) {
      var tmp = "hello world";
    }
  }

  f(); // undefined
  ```
  - 用来计数的循环变量泄漏为全局变量
  ```js
  var s = 'hello';
  for (var i = 0; i < s.length; i++) {
    console.log(s[i]);
  }
  console.log(i); // 5
  ```
- 存在变量提升
- 可以重复声明

### let
- 不存在变量提升
- 不能重复声明
- 存在暂时性死区
- 块级作用域，只在块内有效

### const
相比let，声明一个只读的常量，一旦声明，常量的值不能改变，声明一个复杂类型，地址指向不能改变

## 五、请说下列最终输出的结果，并解释为什么。
```js
var a = 10
var obj = {
  a: 20,
  fn () {
    setTimeout(() => {
      console.log(this.a)
    })
  }
}
obj.fn()
```
- 1.以函数的形式调用时，this是window
- 2.以方法的形式调用时，this就是调用方法的对象
- 3.以构造函数的形式调用时，this就是新创建的对象

## 六、简述Symbol类型的用途
ES5的对象属性名都是字符串，这容易造成属性名的冲突。比如说使用了一个他人提供的对象，但又想为这个对象添加新的方法，新方法的名字就有可能与现有方法产生冲突。Es6引入了一种新的原始数据类型symbol,表示独一无二的值。
- 不能new，symbol是一个原始类型的值，不是对象
- Symbol函数的参数只是表示对当前 Symbol 值的描述，因此相同参数的Symbol函数的返回值是不相等的。
```js
const obj = {
  toString() {
    return 'abc';
  }
};
const sym = Symbol(obj);
```

## 七、说说什么是浅拷贝，什么是深拷贝？
- 浅拷贝：也就是拷贝A对象里面的属性，但是不拷贝A对象里面的子对象,指向同一个地址，改变操作对象另一个也会改变
  - 扩展运算符 // ...
  - Object.assign()
- 深拷贝：会克隆出一个对象，数据相同，但是引用地址不同.
  - _.cloneDeep(value) //递归拷贝对象
  - JSON.stringify()
  - JSON.parse()
## 八、请简述TypeScript与JavaScript之间的关系
typescript是Javascript的超集，补充，javascript是弱类型语言，没有类型限制，提供了很多新语法概念，类型检查，接口，泛型，元组...

## 九、请谈谈你所认为的TypeScript优缺点
- 优点
  - 适用于大型项目
  - 对于很多问题，可以在编译时发现，不会等到运行时，避免很多隐患
  - 代码更牢靠，有利于长期维护
- 缺点
相对于JavaScript，开发效率低


## 十、描述引用计数的工作原理和优缺点
- 原理：设置引用数，判断当前引用数是否为0来判断是否需要清除
#### 优点
  - 及时回收垃圾对象，最大程度的减少卡顿
#### 缺点
  - 时间开销大
  - 无法回收循环引用的对象，造成内存浪费

## 十一、描述标记整理算法的工作流程
- 标记整理可以看做是标记清除的增强
- 标记阶段的操作和标记整理清除一致
- 清除阶段的操作和标记清除一致
- 先整理地址空间，不会立即回收垃圾对象

## 十二、描述V8中新生代存储区垃圾回收的流程
- 回收过程采用复制算法+标记整理
- 新生代内存区分为二个等大小空间
- 使用空间为From，空闲空间为To
- 活动对象存储于From空间
- 标记整理后将活动对象拷贝至To
- From与To交换空间完成释放

## 十三、描述增量标记算法在何时使用及工作原理